<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ocean.xyz Pool Miner - Initializing...</title>
    <!-- Favicon -->
    <link rel="icon" href="/static/favicon/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="/static/favicon/favicon.ico" type="image/x-icon">
    <!-- Enhanced Favicon Support -->
    <link rel="icon" href="/static/favicon/favicon.ico" sizes="any">
    <link rel="icon" href="/static/favicon/favicon-16x16.png" sizes="16x16" type="image/png">
    <link rel="icon" href="/static/favicon/favicon-32x32.png" sizes="32x32" type="image/png">
    <link rel="apple-touch-icon" href="/static/favicon/apple-touch-icon.png">
    <link rel="manifest" href="/static/favicon/site.webmanifest">
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/boot.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/theme-toggle.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/matrix.css') }}">
    <!-- Add Theme JS -->
    <script src="{{ url_for('static', filename='js/theme.js') }}"></script>
    <script src="{{ url_for('static', filename='js/matrixRain.js') }}"></script>
    <script>
        (function () {
            if (localStorage.getItem('hasStartedBefore') !== 'true') {
                localStorage.setItem('useDeepSeaTheme', 'true');
                localStorage.setItem('hasStartedBefore', 'true');
            }

            const useMatrix = localStorage.getItem('useMatrixTheme') === 'true';
            const useDeepSea = !useMatrix && localStorage.getItem('useDeepSeaTheme') === 'true';
            const themeClass = useMatrix ? 'matrix-theme' : (useDeepSea ? 'deepsea-theme' : 'bitcoin-theme');
            document.documentElement.classList.add(themeClass);
        })();
    </script>

    <!-- Water Beading and Dripping Effects CSS -->
    <style>
        /* Water Droplet and Dripping Effects */
        .water-droplet {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            box-shadow: inset 10px 10px 10px rgba(255, 255, 255, 0.3), inset -10px -10px 10px rgba(0, 0, 0, 0.3), 0 0 5px rgba(255, 255, 255, 0.5);
            transform-origin: center bottom;
            z-index: 1000;
            pointer-events: none;
            /* Add fade-in animation and transition properties */
            opacity: 0;
            transform: scale(0.3);
            transition: opacity 1.2s ease-in-out, transform 1s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            backdrop-filter: blur(2.5px) contrast(1.2);
            /* Optionally add: */
            -webkit-backdrop-filter: blur(2.5px) contrast(1.2);
        }

            .water-droplet::before {
                content: '';
                position: absolute;
                top: 10%;
                left: 15%;
                width: 30%;
                height: 30%;
                background-color: rgba(255, 255, 255, 0.7);
                border-radius: 50%;
                z-index: 1001;
            }

            .water-droplet.dripping {
                animation: dropletDrip var(--drip-duration, 4s) linear forwards;
            }

        /* Make water trails also fade in smoothly */
        .water-trail {
            position: absolute;
            background: linear-gradient(to bottom, transparent, rgba(255, 255, 255, 0.3) 20%, rgba(255, 255, 255, 0.2) 70%, transparent);
            z-index: 999;
            pointer-events: none;
            border-radius: 50% 50% 0 0 / 80% 80% 0 0;
            opacity: 0;
            transition: opacity 0.8s ease-in-out;
        }

        /* New fade-in animation for water droplets */
        @keyframes dropletFadeIn {
            0% {
                opacity: 0;
                transform: scale(0.3);
            }

            100% {
                opacity: 1;
                transform: scale(1);
            }
        }

        /* Droplets for DeepSea Theme */
        body.deepsea-theme .water-droplet {
            background-color: rgba(0, 136, 204, 0.3);
            box-shadow: inset 5px 5px 10px rgba(255, 255, 255, 0.3), inset -5px -5px 10px rgba(0, 0, 0, 0.3), 0 0 5px rgba(0, 136, 204, 0.5);
        }

            body.deepsea-theme .water-droplet::before {
                background-color: rgba(255, 255, 255, 0.5);
            }

        body.deepsea-theme .water-trail {
            background: linear-gradient(to bottom, transparent, rgba(0, 136, 204, 0.2) 20%, rgba(0, 136, 204, 0.1) 70%, transparent);
        }

        /* Update dripping animation to work with the new fade-in */
        @keyframes dropletDrip {
            0% {
                transform: translateY(0) scale(1);
            }

            60% {
                transform: translateY(var(--drip-distance)) scale(1.1, 0.9);
            }

            80% {
                transform: translateY(var(--drip-distance)) scale(0.95, 1.05);
            }

            100% {
                transform: translateY(var(--drip-distance)) scale(0.9);
                opacity: 0;
            }
        }

        /* Screen condensation effect - creates a foggy appearance */
        .screen-condensation {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: url('data:image/png;base64,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'), linear-gradient(0deg, rgba(255, 255, 255, 0.03), rgba(255, 255, 255, 0.05));
            pointer-events: none;
            opacity: 0.2;
            z-index: 5;
        }

        /* DeepSea Theme Condensation */
        body.deepsea-theme .screen-condensation {
            background-image: url('data:image/png;base64,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'), linear-gradient(0deg, rgba(0, 136, 204, 0.03), rgba(0, 136, 204, 0.05));
            opacity: 0.2;
        }

        /* Add wobble animation */
        @keyframes dropletWobble {
            0%, 100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05, 0.95);
            }
        }

        #config-form {
            max-height: 70vh;
            overflow-y: auto;
        }
    </style>

    <!-- Add Boot Sequence Bypass Logic -->
    <script>
        // Check if we should bypass boot sequence and go directly to dashboard
        (function () {
            // Only try to bypass if we've booted before
            const hasBootedBefore = localStorage.getItem('hasCompletedBootSequence') === 'true';

            if (hasBootedBefore) {
                console.log("Boot sequence previously completed, checking configuration...");

                // Check if configuration exists and is valid
                fetch('/api/config?nocache=' + new Date().getTime())
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('Configuration check failed');
                        }
                        return response.json();
                    })
                    .then(config => {
                        // Check if configuration has a valid wallet (not default/empty)
                        const isConfigured = config.wallet &&
                            config.wallet !== "yourwallethere" &&
                            config.wallet.trim() !== "";

                        if (isConfigured) {
                            console.log("Valid configuration found, bypassing boot sequence");
                            window.location.href = window.location.origin + "/dashboard";
                        } else {
                            console.log("Configuration invalid or incomplete, showing boot sequence");
                            // Continue with normal boot sequence
                        }
                    })
                    .catch(error => {
                        console.error("Error checking configuration:", error);
                        // On error, continue with boot sequence
                    });
            }
        })();
    </script>
</head>
<body>
    <script>
        // Configuration for water droplets - add mobile detection
        document.addEventListener('DOMContentLoaded', function () {
            const isDeepSeaTheme = localStorage.getItem('useDeepSeaTheme') === 'true';
            if (!isDeepSeaTheme) {
                // Skip droplet effects entirely when not using the DeepSea theme
                return;
            }

            // Create underwater light rays
            const rays = document.createElement('div');
            rays.className = 'underwater-rays';
            document.body.appendChild(rays);

            // Create digital noise
            const noise = document.createElement('div');
            noise.className = 'digital-noise';
            document.body.appendChild(noise);

            // Add water beading and dripping effects
            // Create condensation effect
            const condensation = document.createElement('div');
            condensation.className = 'screen-condensation';
            document.body.appendChild(condensation);

            document.body.classList.add('deepsea-theme');

            // Check if we're on a mobile device
            const isMobile = window.innerWidth < 768;

            // Configuration for water droplets - reduce density for mobile
            const dropletConfig = {
                minSize: isMobile ? 6 : 7,
                maxSize: isMobile ? 20 : 25,
                count: isMobile ? 6 : 12,          // Fewer droplets for mobile
                dripProbability: 0.2,              // Probability of a droplet dripping
                minDripDistance: isMobile ? 50 : 70,    // Minimum distance for droplets to drip
                maxDripDistance: isMobile ? 180 : 250,  // Maximum distance for droplets to drip
                minDripDuration: isMobile ? 3.5 : 3,     // Min animation duration in seconds
                maxDripDuration: isMobile ? 8 : 7      // Max animation duration in seconds
            };

            // Create initial set of droplets
            createInitialDroplets(dropletConfig);

            // Randomly select a non-dripping droplet and make it drip
            function initiateRandomDrip(config) {
                const droplets = Array.from(document.querySelectorAll('.water-droplet:not(.dripping)'));
                if (droplets.length === 0) return;

                // Pick a random droplet to drip
                const randomIndex = Math.floor(Math.random() * droplets.length);
                const selectedDroplet = droplets[randomIndex];

                makeDropletDrip(selectedDroplet, config);
            }

            // Periodically add new droplets - less frequently on mobile
            setInterval(() => {
                // Check current device type again in case of resize
                const currentIsMobile = window.innerWidth < 768;
        
                // Update max droplets based on current screen size
                const maxDroplets = currentIsMobile ? dropletConfig.count * 1.2 : dropletConfig.count * 1.5;
        
                const currentDroplets = document.querySelectorAll('.water-droplet').length;
                if (currentDroplets < maxDroplets) {
                    createDroplet(dropletConfig);
                }
            }, isMobile ? 8000 : 5000);  // Less frequent droplet generation on mobile

            // Start the dripping process - less frequent on mobile
            setInterval(() => {
                initiateRandomDrip(dropletConfig);
            }, isMobile ? 8000 : 6000);

            // Periodically merge nearby droplets for more realistic behaviour
            setInterval(() => {
                checkDropletMerge(dropletConfig);
            }, 4000);

            // Handle window resizing to adjust droplets when switching from desktop to mobile
            window.addEventListener('resize', function() {
                const nowMobile = window.innerWidth < 768;
                const droplets = document.querySelectorAll('.water-droplet');
        
                if (nowMobile && droplets.length > dropletConfig.count * 1.2) {
                    // Remove excess droplets when switching to mobile
                    const dropletsToRemove = droplets.length - Math.floor(dropletConfig.count * 1.2);
            
                    // Remove non-dripping droplets first
                    const staticDroplets = Array.from(document.querySelectorAll('.water-droplet:not(.dripping)'));
            
                    for (let i = 0; i < dropletsToRemove && i < staticDroplets.length; i++) {
                        if (staticDroplets[i].parentNode) {
                            staticDroplets[i].parentNode.removeChild(staticDroplets[i]);
                        }
                    }
                }
            });

            // Make droplets drip on mouse move (throttled)
            let lastDripTime = 0;
            document.addEventListener('mousemove', function () {
                const now = Date.now();
                // Throttle to avoid excessive drips
                if (now - lastDripTime < 3000) return;
                lastDripTime = now;

                const droplets = Array.from(document.querySelectorAll('.water-droplet:not(.dripping)'));
                if (droplets.length === 0) return;

                // Pick a random droplet to drip
                const randomIndex = Math.floor(Math.random() * droplets.length);
                const selectedDroplet = droplets[randomIndex];

                // Use the same config as initial droplets
                makeDropletDrip(selectedDroplet, dropletConfig);
            });

            // Update this function to create more realistic droplet shapes
            // Optional 'options' parameter allows overriding position/size when
            // creating droplets programmatically (e.g. when merging)
            function createDroplet(config, options = {}) {
                const droplet = document.createElement('div');
                droplet.className = 'water-droplet';

                // Random properties
                const size = options.size !== undefined
                    ? options.size
                    : Math.floor(Math.random() * (config.maxSize - config.minSize) + config.minSize);
                // Make some droplets slightly oval for realism
                const heightRatio = options.heightRatio !== undefined
                    ? options.heightRatio
                    : 1 + (Math.random() * 0.25);
                const leftPosition = options.leftPercent !== undefined
                    ? options.leftPercent
                    : Math.random() * 90; // percentage of screen width
                const topPosition = options.topPercent !== undefined
                    ? options.topPercent
                    : Math.random() * 90;  // percentage of screen height

                // Set droplet styles
                droplet.style.width = `${size}px`;
                droplet.style.height = `${size * heightRatio}px`;
                droplet.style.left = `${leftPosition}%`;
                droplet.style.top = `${topPosition}%`;

                // Add slight random rotation for more natural appearance
                if (Math.random() > 0.5) {
                    const rotation = Math.random() * 20 - 10; // -10 to 10 degrees
                    droplet.style.transform = `rotate(${rotation}deg)`;
                }

                // Add to document (still invisible)
                document.body.appendChild(droplet);

                // Force a reflow before starting animations
                void droplet.offsetWidth;

                // Trigger smooth appearance
                setTimeout(() => {
                    droplet.style.opacity = '1';
                    droplet.style.transform = 'scale(1)';

                    // Add slight random wobble animation to some droplets
                    if (Math.random() > 0.6) {
                        const wobbleDuration = 2 + Math.random() * 3;
                        droplet.style.animation = `dropletWobble ${wobbleDuration}s infinite alternate ease-in-out`;
                    }
                }, 10);

                return droplet;
            }

            // Improved makeDropletDrip function for more realistic water streaks
            function makeDropletDrip(droplet, config) {
                // Get current position
                const rect = droplet.getBoundingClientRect();
                const startX = rect.left;
                const startY = rect.top;
                const dropletWidth = rect.width;
                const dropletHeight = rect.height;

                // Calculate drip distance - avoid very short drips
                const dripDistance = Math.floor(Math.random() *
                    (config.maxDripDistance - config.minDripDistance) +
                    config.minDripDistance);

                // Calculate duration based on distance for more natural physics
                const baseDuration = Math.sqrt(dripDistance) / 4;
                const dripDuration = baseDuration +
                    (Math.random() * (config.maxDripDuration - config.minDripDuration) / 3);

                // Create water trail element that follows behind the droplet
                const trail = document.createElement('div');
                trail.className = 'water-trail';

                // Randomize skew and rotation for realism
                const skew = (Math.random() - 0.5) * 6; // -3deg to +3deg
                const rotate = (Math.random() - 0.5) * 4; // -2deg to +2deg
                trail.style.transform = `skewX(${skew}deg) rotate(${rotate}deg)`;

                // Position it more precisely relative to the droplet
                trail.style.left = `${startX + (dropletWidth / 2) - (dropletWidth * 0.25)}px`;
                trail.style.top = `${startY + dropletHeight - 2}px`;
                trail.style.width = `${dropletWidth * 0.5}px`;
                document.body.appendChild(trail);

                // Force reflow before starting animations
                void trail.offsetWidth;

                // Remove any custom transform (rotation/wobble) before dripping
                droplet.style.transform = '';
                droplet.style.animation = '';

                // Mark droplet as dripping
                droplet.classList.add('dripping');

                // Set CSS variables for the animation with proper timing
                droplet.style.setProperty('--drip-distance', `${dripDistance}px`);
                droplet.style.setProperty('--drip-duration', `${dripDuration}s`);

                // Start with a short trail
                trail.style.height = '0px';

                // Fade in the trail
                setTimeout(() => {
                    trail.style.opacity = '1';
                }, 10);

                // Animate trail height, width (taper), and optional wobble
                let startTime = null;
                const trailMaxHeight = dripDistance;
                const startWidth = dropletWidth * 0.5;
                const endWidth = startWidth * 0.45 + Math.random() * (startWidth * 0.15); // taper to 45-60% of start

                function updateTrail(timestamp) {
                    if (!startTime) startTime = timestamp;

                    // Calculate progress as a value between 0 and 1
                    const elapsed = timestamp - startTime;
                    const progress = Math.min(elapsed / (dripDuration * 1000), 1);

                    if (progress < 1) {
                        // Trail grows in height
                        const newHeight = progress * trailMaxHeight;
                        trail.style.height = `${newHeight}px`;

                        // Trail tapers in width
                        const currentWidth = startWidth - (startWidth - endWidth) * progress;
                        trail.style.width = `${currentWidth}px`;

                        // Optional: subtle horizontal "wobble" as it grows
                        const wobble = Math.sin(progress * Math.PI * 2) * 2; // -2px to +2px
                        trail.style.left = `${startX + (dropletWidth / 2) - (currentWidth / 2) + wobble}px`;

                        requestAnimationFrame(updateTrail);
                    } else {
                        // When complete, fade out trail
                        trail.style.transition = 'opacity 0.8s ease-out';
                        trail.style.opacity = '0';

                        setTimeout(() => {
                            if (trail.parentNode) {
                                trail.parentNode.removeChild(trail);
                            }
                        }, 800);
                    }
                }

                // Start the animation loop
                requestAnimationFrame(updateTrail);

                // Remove droplet after animation and create a new one with smooth fade-out
                setTimeout(() => {
                    droplet.style.transition = 'opacity 0.8s ease-out, transform 0.5s ease-in-out';
                    droplet.style.opacity = '0';

                    setTimeout(() => {
                        if (droplet.parentNode) {
                            droplet.parentNode.removeChild(droplet);
                        }
                        createDroplet(config);
                    }, 800);
                }, dripDuration * 1000);
            }

            // Also update the initial droplet creation with improved staggering
            function createInitialDroplets(config) {
                // Apply the improved CSS first
                updateWaterTrailsCSS();

                // Create droplets with a staggered delay for a more natural appearance
                for (let i = 0; i < config.count; i++) {
                    setTimeout(() => {
                        createDroplet(config);

                        // Start some droplets already dripping for immediate visual effect
                        if (i > config.count / 2 && Math.random() > 0.7) {
                            setTimeout(() => {
                                const droplets = document.querySelectorAll('.water-droplet:not(.dripping)');
                                if (droplets.length > 0) {
                                    const randomIndex = Math.floor(Math.random() * droplets.length);
                                    makeDropletDrip(droplets[randomIndex], config);
                                }
                            }, 500 + Math.random() * 1000);
                        }
                    }, i * 200); // 200ms delay between each initial droplet
                }
            }

            // Update CSS for the water-trail to improve the appearance
            function updateWaterTrailsCSS() {
                // Create a style element
                const styleEl = document.createElement('style');
                styleEl.innerHTML = `
                    .water-trail {
                        position: absolute;
                        pointer-events: none;
                        z-index: 999;
                        border-radius: 100% 100% 0 0 / 100% 100% 0 0;
                        opacity: 0;
                        background: linear-gradient(
                            to bottom,
                            rgba(255,255,255,0.7) 0%,
                            rgba(255,255,255,0.3) 20%,
                            rgba(255,255,255,0.15) 60%,
                            transparent 100%
                        );
                        box-shadow: 0 2px 8px 0 rgba(0,0,0,0.08) inset;
                        mask-image: linear-gradient(to bottom, rgba(0,0,0,1) 0%, rgba(0,0,0,0.2) 80%, rgba(0,0,0,0) 100%);
                        -webkit-mask-image: linear-gradient(to bottom, rgba(0,0,0,1) 0%, rgba(0,0,0,0.2) 80%, rgba(0,0,0,0) 100%);
                        backdrop-filter: blur(1.5px) brightness(1.1) contrast(1.1);
                        -webkit-backdrop-filter: blur(1.5px) brightness(1.1) contrast(1.1);
                        transition: opacity 0.3s, height 0.3s, width 0.3s;
                        will-change: opacity, height, width;
                    }

                    body.deepsea-theme .water-trail {
                        background: linear-gradient(to bottom, 
                            rgba(0, 136, 204, 0.05) 0%,
                            rgba(0, 136, 204, 0.25) 10%, 
                            rgba(0, 136, 204, 0.1) 60%, 
                            transparent 100%);
                    }
        
                    /* Update droplet drip animation for smoother movement */
                    @keyframes dropletDrip {
                        0% {
                            transform: translateY(0) scale(1);
                            animation-timing-function: ease-in;
                        }
            
                        40% {
                            transform: translateY(calc(var(--drip-distance) * 0.6)) scale(1.05, 0.95);
                            animation-timing-function: ease-in-out;
                        }
            
                        60% {
                            transform: translateY(calc(var(--drip-distance) * 0.8)) scale(0.98, 1.02);
                            animation-timing-function: ease-in-out;
                        }
            
                        85% {
                            transform: translateY(var(--drip-distance)) scale(1, 1);
                            animation-timing-function: ease-out;
                            opacity: 1;
                        }
            
                        100% {
                            transform: translateY(var(--drip-distance)) scale(0.9);
                            opacity: 0;
                        }
                    }
                `;
                document.head.appendChild(styleEl);
            }

            // Detect collisions between droplets and merge them into a larger
            // droplet positioned midway between the originals
            function checkDropletMerge(config) {
                const droplets = Array.from(document.querySelectorAll('.water-droplet:not(.dripping)'));
                for (let i = 0; i < droplets.length; i++) {
                    for (let j = i + 1; j < droplets.length; j++) {
                        const rect1 = droplets[i].getBoundingClientRect();
                        const rect2 = droplets[j].getBoundingClientRect();

                        const c1x = rect1.left + rect1.width / 2;
                        const c1y = rect1.top + rect1.height / 2;
                        const c2x = rect2.left + rect2.width / 2;
                        const c2y = rect2.top + rect2.height / 2;

                        const dist = Math.hypot(c1x - c2x, c1y - c2y);
                        const radius1 = Math.min(rect1.width, rect1.height) / 2;
                        const radius2 = Math.min(rect2.width, rect2.height) / 2;

                        if (dist < (radius1 + radius2) * 0.8) {
                            if (droplets[i].parentNode) droplets[i].parentNode.removeChild(droplets[i]);
                            if (droplets[j].parentNode) droplets[j].parentNode.removeChild(droplets[j]);

                            const newArea = rect1.width * rect1.height + rect2.width * rect2.height;
                            const newSize = Math.sqrt(newArea);
                            const bodyRect = document.body.getBoundingClientRect();
                            const newLeft = ((c1x + c2x) / 2 - newSize / 2 - bodyRect.left) / bodyRect.width * 100;
                            const newTop = ((c1y + c2y) / 2 - newSize / 2 - bodyRect.top) / bodyRect.height * 100;

                            const merged = createDroplet(config, {
                                size: newSize,
                                leftPercent: newLeft,
                                topPercent: newTop,
                                heightRatio: 1 + Math.random() * 0.1
                            });

                            if (Math.random() < config.dripProbability) {
                                setTimeout(() => makeDropletDrip(merged, config), 1000);
                            }
                            return;
                        }
                    }
                }
            }
        });
    </script>
    <!-- Theme toggle button (new) -->
    <button id="themeToggle" class="theme-toggle-btn">
        <span></span>
    </button>
    <button id="skip-button">SKIP</button>
    <div id="debug-info"></div>
    <div id="loading-message">Loading mining data...</div>
    <div id="bitcoin-logo">
        <pre>
██████╗ ████████╗ ██████╗   ██████╗ ███████╗
██╔══██╗╚══██╔══╝██╔════╝  ██╔═══██╗██╔════╝
██████╔╝   ██║   ██║       ██║   ██║███████╗
██╔══██╗   ██║   ██║       ██║   ██║╚════██║
██████╔╝   ██║   ╚██████╗  ╚██████╔╝███████║
╚═════╝    ╚═╝    ╚═════╝   ╚═════╝ ╚══════╝
        v.21
        </pre>
    </div>
    <div id="terminal">
        <div id="terminal-content">
            <span id="output"></span><span class="cursor"></span>
            <span id="prompt-container">
                <span id="prompt-text">
                    Initialize mining dashboard? [Y/N]:
                    <span class="prompt-cursor"></span>
                    <input type="text" id="user-input" maxlength="1" autocomplete="off" spellcheck="false" autofocus style="font-size: 16px; font-weight: bold;">
                </span>
            </span>
        </div>
    </div>

    <!-- Configuration Form -->
    <div id="config-form">
        <div class="config-title">MINING CONFIGURATION</div>
        <div class="form-group">
            <label for="wallet-address">
                Bitcoin Wallet Address
                <span class="tooltip">
                    ?
                    <span class="tooltip-text">Your Ocean.xyz pool mining address</span>
                </span>
            </label>
            <input type="text" id="wallet-address" placeholder="bc1..." value="">
        </div>
        <div class="form-group">
            <label for="currency">
                Preferred Currency
                <span class="tooltip">
                    ?
                    <span class="tooltip-text">Currency for displaying BTC value and earnings</span>
                </span>
            </label>
            <select id="currency" class="form-control">
                <option value="USD">USD ($)</option>
                <option value="EUR">EUR (€)</option>
                <option value="GBP">GBP (£)</option>
                <option value="JPY">JPY (¥)</option>
                <option value="CAD">CAD ($)</option>
                <option value="AUD">AUD ($)</option>
                <option value="CNY">CNY (¥)</option>
                <option value="KRW">KRW (₩)</option>
                <option value="BRL">BRL (R$)</option>
                <option value="CHF">CHF (Fr)</option>
            </select>
        </div>
        <div class="form-group">
            <label for="power-cost">
                Power Cost ($/kWh)
                <span class="tooltip">
                    ?
                    <span class="tooltip-text">Your electricity cost per kilowatt-hour</span>
                </span>
            </label>
            <input type="number" id="power-cost" step="0.01" min="0" placeholder="0.12" value="">
        </div>
        <div class="form-group">
            <label for="power-usage">
                Power Usage (Watts)
                <span class="tooltip">
                    ?
                    <span class="tooltip-text">Total power consumption of your mining equipment</span>
                </span>
            </label>
            <input type="number" id="power-usage" step="50" min="0" placeholder="13450" value="">
        </div>
        <div class="form-group">
            <label for="network-fee">
                Firmware/Other Fees (%)
                <span class="tooltip">
                    ?
                    <span class="tooltip-text">Additional fees beyond pool fee, like Firmware fees</span>
                </span>
            </label>
            <input type="number" id="network-fee" step="0.1" min="0" max="10" placeholder="0.0" value="">
        </div>
        <div class="form-group">
            <label for="timezone">
                Timezone
                <span class="tooltip">
                    ?
                    <span class="tooltip-text">Your local timezone for displaying time information</span>
                </span>
            </label>
            <select id="timezone" class="form-control">
                <optgroup label="Common Timezones">
                    <option value="America/Los_Angeles">Los Angeles (Pacific Time)</option>
                    <option value="America/Denver">Denver (Mountain Time)</option>
                    <option value="America/Chicago">Chicago (Central Time)</option>
                    <option value="America/New_York">New York (Eastern Time)</option>
                    <option value="Europe/London">London (GMT/BST)</option>
                    <option value="Europe/Paris">Paris (Central European Time)</option>
                    <option value="Asia/Tokyo">Tokyo (Japan Standard Time)</option>
                    <option value="Australia/Sydney">Sydney (Australian Eastern Time)</option>
                </optgroup>
                <optgroup label="Other Timezones" id="other-timezones">
                    <!-- Will be populated by JavaScript -->
                </optgroup>
            </select>
        </div>
        <div id="form-message"></div>
        <div class="form-actions">
            <button class="btn btn-secondary" id="use-defaults">Use Defaults</button>
            <button class="btn" id="save-config">Save & Continue</button>
        </div>
    </div>

    <script>
        // Theme toggle initialization
        document.addEventListener('DOMContentLoaded', function () {
            // Initialize theme toggle button based on current theme
            const themeToggle = document.getElementById('themeToggle');
            if (themeToggle) {
                const isMatrix = localStorage.getItem('useMatrixTheme') === 'true';
                const isDeepSea = !isMatrix && localStorage.getItem('useDeepSeaTheme') === 'true';

                if (isMatrix) {
                    themeToggle.style.borderColor = '#39ff14';
                    themeToggle.style.color = '#39ff14';
                    if (window.applyMatrixTheme) {
                        applyMatrixTheme();
                    }
                } else if (isDeepSea) {
                    document.body.classList.add('deepsea-theme');
                    themeToggle.style.borderColor = '#0088cc';
                    themeToggle.style.color = '#0088cc';
                    if (window.applyDeepSeaTheme) {
                        applyDeepSeaTheme();
                    }
                } else {
                    document.body.classList.remove('deepsea-theme');
                    themeToggle.style.borderColor = '#f2a900';
                    themeToggle.style.color = '#f2a900';
                }

                // Add click event listener
                themeToggle.addEventListener('click', function () {
                    toggleTheme(); // This will now trigger a page refresh
                });
            }

            // Update terminal colors based on theme (boot.html specific)
            function updateTerminalColors() {
                const isMatrix = localStorage.getItem('useMatrixTheme') === 'true';
                const isDeepSeaTheme = !isMatrix && localStorage.getItem('useDeepSeaTheme') === 'true';
                document.body.classList.toggle('deepsea-theme', isDeepSeaTheme);
                if (isMatrix && window.applyMatrixTheme) {
                    applyMatrixTheme();
                }
            }

            // Initialize terminal colors
            updateTerminalColors();
        });

        // Add a function to populate all available timezones
        function populateTimezones() {
            const otherTimezones = document.getElementById('other-timezones');

            // Common timezone areas to include
            const commonAreas = [
                'Africa', 'America', 'Antarctica', 'Asia', 'Atlantic',
                'Australia', 'Europe', 'Indian', 'Pacific'
            ];

            // Fetch the list of available timezones
            fetch('/api/available_timezones')
                .then(response => response.json())
                .then(data => {
                    if (!data.timezones || !Array.isArray(data.timezones)) {
                        console.error('Invalid timezone data received');
                        return;
                    }

                    // Sort timezones and filter to include only common areas
                    const sortedTimezones = data.timezones
                        .filter(tz => commonAreas.some(area => tz.startsWith(area + '/')))
                        .sort();

                    // Add options for each timezone (excluding those already in common list)
                    const commonOptions = Array.from(document.querySelectorAll('#timezone optgroup:first-child option'))
                        .map(opt => opt.value);

                    sortedTimezones.forEach(tz => {
                        if (!commonOptions.includes(tz)) {
                            const option = document.createElement('option');
                            option.value = tz;
                            option.textContent = tz.replace('_', ' ');
                            otherTimezones.appendChild(option);
                        }
                    });
                })
                .catch(error => console.error('Error fetching timezones:', error));
        }

        // Call this when the page loads
        document.addEventListener('DOMContentLoaded', populateTimezones);

        // Load the current timezone from configuration
        function loadTimezoneFromConfig() {
            if (currentConfig && currentConfig.timezone) {
                const timezoneSelect = document.getElementById('timezone');

                // First, check if the option exists
                let optionExists = false;
                for (let i = 0; i < timezoneSelect.options.length; i++) {
                    if (timezoneSelect.options[i].value === currentConfig.timezone) {
                        timezoneSelect.selectedIndex = i;
                        optionExists = true;
                        break;
                    }
                }

                // If the option doesn't exist yet (might be in the 'other' group being loaded)
                // set a data attribute to select it when options are loaded
                if (!optionExists) {
                    timezoneSelect.setAttribute('data-select-value', currentConfig.timezone);
                }
            }
        }

        // Call this after loading config
        loadConfig().then(() => {
            loadTimezoneFromConfig();
        });

        // Update saveConfig to include currency
        function saveConfig() {
            const wallet = document.getElementById('wallet-address').value.trim();
            const powerCost = parseFloat(document.getElementById('power-cost').value) || 0;
            const powerUsage = parseFloat(document.getElementById('power-usage').value) || 0;
            const timezone = document.getElementById('timezone').value;
            const networkFee = parseFloat(document.getElementById('network-fee').value) || 0;
            const currency = document.getElementById('currency').value;

            const updatedConfig = {
                wallet: wallet || (currentConfig ? currentConfig.wallet : ""),
                power_cost: powerCost,
                power_usage: powerUsage,
                timezone: timezone,
                network_fee: networkFee,
                currency: currency
            };

            return fetch('/api/config', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(updatedConfig)
            })
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Failed to save configuration');
                    }
                    return response.json();
                });
        }

        // Debug logging
        function updateDebug(message) {
            document.getElementById('debug-info').textContent = message;
            console.log(message);
        }

        // Format numbers with commas
        function numberWithCommas(x) {
            if (x == null) return "N/A";
            return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
        }

        // Global variables
        let bootMessages = [];
        let dashboardData = null;
        let outputElement = document.getElementById('output');
        const bitcoinLogo = document.getElementById('bitcoin-logo');
        const skipButton = document.getElementById('skip-button');
        const loadingMessage = document.getElementById('loading-message');
        const promptContainer = document.getElementById('prompt-container');
        const userInput = document.getElementById('user-input');
        const configForm = document.getElementById('config-form');
        let messageIndex = 0;
        let timeoutId = null;
        let waitingForUserInput = false;
        let bootComplete = false;
        let configLoaded = false;
        let currentConfig = {
            wallet: "yourwallethere",
            power_cost: 0.0,
            power_usage: 0.0
        };

        // Update loadConfig function to handle currency
        function loadConfig() {
            return new Promise((resolve, reject) => {
                fetch('/api/config?nocache=' + new Date().getTime())
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('Failed to load configuration: ' + response.statusText);
                        }
                        return response.json();
                    })
                    .then(data => {
                        console.log("Loaded configuration:", data);
                        currentConfig = data;

                        // Update form fields with latest values
                        document.getElementById('wallet-address').value = currentConfig.wallet || "";
                        document.getElementById('power-cost').value = currentConfig.power_cost || "";
                        document.getElementById('power-usage').value = currentConfig.power_usage || "";
                        document.getElementById('network-fee').value = currentConfig.network_fee || "";

                        // Set currency dropdown value if available
                        if (currentConfig.currency) {
                            document.getElementById('currency').value = currentConfig.currency;
                        }

                        configLoaded = true;
                        resolve(currentConfig);
                    })
                    .catch(err => {
                        console.error("Error loading config:", err);
                        // Use default values if loading fails
                        currentConfig = {
                            wallet: "yourwallethere",
                            power_cost: 0.0,
                            power_usage: 0.0,
                            network_fee: 0.0,
                            currency: "USD"
                        };

                        document.getElementById('wallet-address').value = currentConfig.wallet || "";
                        document.getElementById('power-cost').value = currentConfig.power_cost || "";
                        document.getElementById('power-usage').value = currentConfig.power_usage || "";
                        document.getElementById('network-fee').value = currentConfig.network_fee || "";
                        document.getElementById('currency').value = currentConfig.currency || "USD";

                        resolve(currentConfig);
                    });
            });
        }

        // Also update the save button event handler to reload the config after saving
        document.getElementById('save-config').addEventListener('click', function () {
            const messageElement = document.getElementById('form-message');
            messageElement.style.display = 'block';

            saveConfig()
                .then(data => {
                    console.log("Configuration saved:", data);
                    messageElement.textContent = "Configuration saved successfully!";
                    messageElement.className = "message-success";

                    // Update currentConfig with the saved values
                    currentConfig = data.config || data;

                    setTimeout(redirectToDashboard, 1000);
                })
                .catch(error => {
                    console.error("Error saving configuration:", error);
                    messageElement.textContent = "Error saving configuration. Please try again.";
                    messageElement.className = "message-error";
                });
        });

        // Safety timeout: redirect after 360 seconds if boot not complete
        window.addEventListener('load', function () {
            setTimeout(function () {
                if (!bootComplete && !waitingForUserInput) {
                    console.warn("Safety timeout reached - redirecting to dashboard");
                    redirectToDashboard();
                }
            }, 360000);
        });

        // Update Use Defaults button handler
        document.getElementById('use-defaults').addEventListener('click', function () {
            // Set default values including network fee
            document.getElementById('wallet-address').value = "35eS5Lsqw8NCjFJ8zhp9JaEmyvLDwg6XtS";
            document.getElementById('power-cost').value = 0.0;
            document.getElementById('power-usage').value = 0.0;
            document.getElementById('network-fee').value = 0.0;

            // Visual feedback
            const btn = document.getElementById('use-defaults');
            const originalText = btn.textContent;
            btn.textContent = "Defaults Applied";
            btn.style.backgroundColor = "#32CD32";
            setTimeout(function () {
                btn.textContent = originalText;
                btn.style.backgroundColor = "";
            }, 1500);
        });

        // Redirect to dashboard
        function redirectToDashboard() {
            updateDebug("Boot sequence complete, redirecting...");
            // Set localStorage flag to indicate boot sequence has been completed
            localStorage.setItem('hasCompletedBootSequence', 'true');
            const baseUrl = window.location.origin;
            window.location.href = baseUrl + "/dashboard";
        }

        // Fade in Bitcoin logo
        document.addEventListener('DOMContentLoaded', function () {
            setTimeout(function () {
                bitcoinLogo.style.visibility = 'visible';
                setTimeout(function () {
                    bitcoinLogo.style.opacity = '1';
                }, 100);
            }, 500);

            // Load configuration
            loadConfig();
        });

        // Post-confirmation messages with retro typing effect
        function showPostConfirmationMessages(response) {
            try {
                outputElement = document.getElementById('output');
                if (!outputElement) {
                    setTimeout(redirectToDashboard, 1000);
                    return;
                }

                // Configuration form will be shown after boot sequence
                if (response.toUpperCase() === 'Y') {
                    const yesMessages = [
                        { text: "INITIALIZING DASHBOARD...\n", html: true, delay: 400 },
                        { text: "Connecting to real-time data feeds...", speed: 20, delay: 300 },
                        { text: "<span class='green'>CONNECTED</span>\n", html: true, delay: 400 },
                        { text: "Loading blockchain validators...", speed: 15, delay: 300 },
                        { text: "<span class='green'>COMPLETE</span>\n", html: true, delay: 400 },
                        { text: "Starting TX fee calculation module...", speed: 15, delay: 400 },
                        { text: "<span class='green'>ACTIVE</span>\n", html: true, delay: 400 },
                        { text: "Verifying BTC-USD exchange rates...", speed: 15, delay: 200 },
                        { text: "<span class='green'>CURRENT RATE CONFIRMED</span>\n", html: true, delay: 300 },
                        { text: "Calibrating hashrate telemetry...", speed: 15, delay: 200 },
                        { text: "<span class='green'>CALIBRATED</span>\n", html: true, delay: 200 },
                        { text: "Loading mining configuration...", speed: 15, delay: 200 },
                        { text: "<span class='green'>LOADED</span>\n", html: true, delay: 300 },
                        { text: "Preparing configuration interface...", speed: 15, delay: 800 },
                        { text: "<span class='green'>READY</span>\n", html: true, delay: 500 },
                        { text: "\nPlease configure your mining setup or use the default values:\n", html: true, delay: 800, showConfigForm: true }
                    ];

                    let msgIndex = 0;
                    function processNextMessage() {
                        if (msgIndex >= yesMessages.length) {
                            return;
                        }
                        const currentMessage = yesMessages[msgIndex];

                        if (currentMessage.showConfigForm) {
                            msgIndex++;
                            // Show configuration form
                            document.getElementById('config-form').style.display = 'block';
                            return;
                        }

                        if (currentMessage.html) {
                            outputElement.innerHTML += currentMessage.text;
                            msgIndex++;
                            setTimeout(processNextMessage, currentMessage.delay || 300);
                        } else {
                            let charIndex = 0;
                            function typeCharacter() {
                                if (charIndex < currentMessage.text.length) {
                                    outputElement.innerHTML += currentMessage.text.charAt(charIndex);
                                    charIndex++;
                                    setTimeout(typeCharacter, currentMessage.speed || 20);
                                } else {
                                    msgIndex++;
                                    setTimeout(processNextMessage, currentMessage.delay || 300);
                                }
                            }
                            typeCharacter();
                        }
                    }
                    setTimeout(processNextMessage, 500);
                } else {
                    // If user selects 'N', show configuration form directly without boot messages
                    outputElement.innerHTML += "N\n\nDASHBOARD INITIALIZATION ABORTED.\n";
                    outputElement.innerHTML += "\nPlease configure your mining setup:\n";

                    // Short pause and then show the configuration form
                    setTimeout(function () {
                        document.getElementById('config-form').style.display = 'block';
                    }, 1000);
                }
            } catch (err) {
                setTimeout(redirectToDashboard, 1000);
            }
        }

        // Handle Y/N prompt input
        userInput.addEventListener('keydown', function (e) {
            if (waitingForUserInput && e.key === 'Enter') {
                e.preventDefault();
                const response = userInput.value.toUpperCase();

                if (response === 'Y' || response === 'N') {
                    promptContainer.style.display = 'none';
                    waitingForUserInput = false;
                    outputElement.innerHTML += response + "\n";
                    userInput.value = '';
                    showPostConfirmationMessages(response);
                }
            }
        });

        // Show the prompt
        function showUserPrompt() {
            promptContainer.style.display = 'inline';
            waitingForUserInput = true;
            document.querySelector('.cursor').style.display = 'none';
            userInput.focus();
        }

        // Disable truncation so all text is visible
        function manageTerminalContent() { }

        // Retro typing effect for boot messages
        function typeBootMessages() {
            try {
                if (!outputElement) {
                    outputElement = document.getElementById('output');
                    if (!outputElement) {
                        skipButton.click();
                        return;
                    }
                }

                if (messageIndex >= bootMessages.length) { return; }
                const currentMessage = bootMessages[messageIndex];

                if (currentMessage.showPrompt) {
                    messageIndex++;
                    showUserPrompt();
                    return;
                }

                if (currentMessage.html) {
                    outputElement.innerHTML += currentMessage.text;
                    messageIndex++;
                    timeoutId = setTimeout(typeBootMessages, currentMessage.delay || 300);
                    return;
                }

                if (!currentMessage.typingIndex) { currentMessage.typingIndex = 0; }
                if (currentMessage.typingIndex < currentMessage.text.length) {
                    outputElement.innerHTML += currentMessage.text.charAt(currentMessage.typingIndex);
                    currentMessage.typingIndex++;
                    timeoutId = setTimeout(typeBootMessages, currentMessage.speed || 15);
                } else {
                    messageIndex++;
                    timeoutId = setTimeout(typeBootMessages, currentMessage.delay || 300);
                }
            } catch (err) {
                messageIndex++;
                timeoutId = setTimeout(typeBootMessages, 500);
            }
        }

        // Skip button: reveal configuration form only
        skipButton.addEventListener('click', function () {
            clearTimeout(timeoutId);
            // Optionally, clear boot messages or hide elements related to boot sequence
            outputElement.innerHTML = "";
            // Hide any loading or prompt messages
            loadingMessage.style.display = 'none';
            promptContainer.style.display = 'none';
            // Show the configuration form
            configForm.style.display = 'block';
        });

        // Start the typing animation (hides loading message)
        function startTyping() {
            loadingMessage.style.display = 'none';
            setTimeout(typeBootMessages, 150);
        }

        // Fallback messages (used immediately)
        function setupFallbackMessages() {
            bootMessages = [
                { text: "BITCOIN OS - MINING CONTROL SYSTEM - v21.000.000\n", speed: 25, delay: 300 },
                { text: "Copyright (c) 2009-2025 Satoshi Nakamoto\n", speed: 20, delay: 250 },
                { text: "All rights reserved.\n\n", speed: 25, delay: 300 },
                { text: "INITIALIZING SYSTEM...\n", speed: 25, delay: 300 },
                { text: "HARDWARE: ", speed: 25, delay: 100 },
                { text: "<span class='green'>OK</span>\n", html: true, delay: 300 },
                { text: "NETWORK: ", speed: 25, delay: 100 },
                { text: "<span class='green'>OK</span>\n", html: true, delay: 300 },
                { text: "BLOCKCHAIN: ", speed: 25, delay: 100 },
                { text: "<span class='green'>SYNCHRONIZED</span>\n", html: true, delay: 300 },
                { text: "MINING RIG: ", speed: 25, delay: 100 },
                { text: "<span class='green'>ONLINE</span>\n", html: true, delay: 300 },
                { text: "\nSystem ready. ", speed: 25, delay: 400 },
                { showPrompt: true, delay: 0 }
            ];
            startTyping();
        }

        // Initialize with fallback, then try live data
        setupFallbackMessages();
        updateDebug("Fetching dashboard data...");
        fetch('/api/metrics')
            .then(response => {
                if (!response.ok) { throw new Error(`HTTP error! Status: ${response.status}`); }
                return response.json();
            })
            .then(data => {
                dashboardData = data;
                clearTimeout(timeoutId);
                messageIndex = 0;
                outputElement = document.getElementById('output');
                outputElement.innerHTML = "";
                bootMessages = [
                    { text: "BITCOIN OS - MINING CONTROL SYSTEM - v21.000.000\n", speed: 25, delay: 300 },
                    { text: "Copyright (c) 2009-2025 Satoshi Nakamoto & The Bitcoin Core Developers\n", speed: 20, delay: 250 },
                    { text: "All rights reserved.\n\n", speed: 25, delay: 300 },
                    { text: "INITIALIZING SHA-256 MINING SUBSYSTEMS...\n", speed: 25, delay: 400 },
                    { text: "ASIC CLUSTER STATUS: ", speed: 15, delay: 100 },
                    { text: "<span class='green'>ONLINE</span>\n", html: true, delay: 300 },
                    { text: "CHIP TEMPERATURE: ", speed: 15, delay: 100 },
                    { text: "<span class='green'>62°C - WITHIN OPTIMAL RANGE</span>\n", html: true, delay: 300 },
                    { text: "COOLING SYSTEMS: ", speed: 15, delay: 100 },
                    { text: "<span class='green'>OPERATIONAL</span>\n", html: true, delay: 300 },
                    { text: "POWER SUPPLY HEALTH: ", speed: 15, delay: 100 },
                    { text: "<span class='green'>98.7% - NOMINAL</span>\n", html: true, delay: 300 },
                    { text: "\nCONNECTING TO BITCOIN NETWORK...\n", speed: 20, delay: 400 },
                    { text: "BLOCKCHAIN SYNC STATUS: ", speed: 15, delay: 100 },
                    { text: "<span class='green'>SYNCHRONIZED</span>\n", html: true, delay: 300 },
                    { text: "DIFFICULTY ADJUSTMENT: ", speed: 15, delay: 100 },
                    { text: "<span class='yellow'>CALCULATED</span>\n", html: true, delay: 300 },
                    { text: "MEMPOOL MONITORING: ", speed: 15, delay: 100 },
                    { text: "<span class='green'>ACTIVE</span>\n", html: true, delay: 300 },
                    { text: "\nESTABLISHING POOL CONNECTION...\n", speed: 20, delay: 300 },
                    { text: "CONNECTING TO OCEAN.XYZ...\n", speed: 20, delay: 300 },
                    { text: "STRATUM PROTOCOL v2: ", speed: 15, delay: 100 },
                    { text: "<span class='green'>INITIALIZED</span>\n", html: true, delay: 300 },
                    { text: "POOL HASHRATE: ", speed: 15, delay: 100 },
                    { text: "<span class='green'>VERIFIED</span>\n", html: true, delay: 300 },
                    { text: "WORKER AUTHENTICATION: ", speed: 15, delay: 100 },
                    { text: "<span class='green'>SUCCESSFUL</span>\n", html: true, delay: 300 },
                    { text: "\nINITIALIZING METRICS COLLECTORS...\n", speed: 20, delay: 300 },
                    { text: "HASHRATE MONITOR: ", speed: 15, delay: 100 },
                    { text: "<span class='green'>ACTIVE</span>\n", html: true, delay: 300 },
                    { text: "EARNINGS CALCULATOR: ", speed: 15, delay: 100 },
                    { text: "<span class='green'>CALIBRATED</span>\n", html: true, delay: 300 },
                    { text: "POWER USAGE TRACKING: ", speed: 15, delay: 100 },
                    { text: "<span class='green'>ENABLED</span>\n", html: true, delay: 300 },
                    { text: "PAYOUT THRESHOLD MONITOR: ", speed: 15, delay: 100 },
                    { text: "<span class='green'>ACTIVE</span>\n", html: true, delay: 300 },
                    { text: "\nCURRENT NETWORK METRICS DETECTED\n", speed: 20, delay: 300 },
                    { text: "BTC PRICE: ", speed: 20, delay: 100 },
                    { text: "<span class='yellow'>$" + numberWithCommas((data.btc_price || 0).toFixed(2)) + "</span>\n", html: true, delay: 300 },
                    { text: "NETWORK DIFFICULTY: ", speed: 20, delay: 100 },
                    { text: "<span class='white'>" + numberWithCommas(Math.round(data.difficulty || 0)) + "</span>\n", html: true, delay: 300 },
                    { text: "NETWORK HASHRATE: ", speed: 20, delay: 100 },
                    { text: "<span class='white'>" + (data.network_hashrate ? numberWithCommas(Math.round(data.network_hashrate)) : "N/A") + " EH/s</span>\n", html: true, delay: 300 },
                    { text: "BLOCK HEIGHT: ", speed: 20, delay: 100 },
                    { text: "<span class='white'>" + numberWithCommas(data.block_number || "N/A") + "</span>\n", html: true, delay: 300 },
                    { text: "\nMINER PERFORMANCE DATA\n", speed: 20, delay: 300 },
                    { text: "CURRENT HASHRATE: ", speed: 20, delay: 100 },
                    { text: "<span class='yellow'>" + (data.hashrate_60sec || "N/A") + " " + (data.hashrate_60sec_unit || "TH/s") + "</span>\n", html: true, delay: 300 },
                    { text: "24HR AVG HASHRATE: ", speed: 20, delay: 100 },
                    { text: "<span class='yellow'>" + (data.hashrate_24hr || "N/A") + " " + (data.hashrate_24hr_unit || "TH/s") + "</span>\n", html: true, delay: 300 },
                    { text: "ACTIVE WORKERS: ", speed: 20, delay: 100 },
                    { text: "<span class='yellow'>" + (data.workers_hashing || "0") + "</span>\n", html: true, delay: 300 },
                    { text: "\nFINANCIAL CALCULATIONS\n", speed: 20, delay: 300 },
                    { text: "DAILY MINING REVENUE: ", speed: 20, delay: 100 },
                    { text: "<span class='green'>$" + numberWithCommas((data.daily_revenue || 0).toFixed(2)) + "</span>\n", html: true, delay: 300 },
                    { text: "DAILY POWER COST: ", speed: 20, delay: 100 },
                    { text: "<span class='red'>$" + numberWithCommas((data.daily_power_cost || 0).toFixed(2)) + "</span>\n", html: true, delay: 300 },
                    { text: "DAILY PROFIT: ", speed: 20, delay: 100 },
                    { text: "<span class='green'>$" + numberWithCommas((data.daily_profit_usd || 0).toFixed(2)) + "</span>\n", html: true, delay: 300 },
                    { text: "PROJECTED MONTHLY PROFIT: ", speed: 20, delay: 100 },
                    { text: "<span class='green'>$" + numberWithCommas((data.monthly_profit_usd || 0).toFixed(2)) + "</span>\n", html: true, delay: 300 },
                    { text: "DAILY SATOSHI YIELD: ", speed: 20, delay: 100 },
                    { text: "<span class='yellow'>" + numberWithCommas(data.daily_mined_sats || 0) + " sats</span>\n", html: true, delay: 300 },
                    { text: "UNPAID EARNINGS: ", speed: 20, delay: 100 },
                    { text: "<span class='green'>" + (data.unpaid_earnings || "0") + " BTC</span>\n", html: true, delay: 300 },
                    { text: "ESTIMATED TIME TO PAYOUT: ", speed: 20, delay: 100 },
                    { text: "<span class='yellow'>" + (data.est_time_to_payout || "Unknown") + "</span>\n", html: true, delay: 300 },
                    { text: "\n", speed: 25, delay: 100 },
                    { text: "<span class='green'>ALL MINING PROCESSES OPERATIONAL</span>\n", html: true, delay: 400 },
                    { showPrompt: true, delay: 0 }
                ];
                startTyping();
            })
            .catch(error => {
                updateDebug(`Error fetching dashboard data: ${error.message}`);
            });
    </script>
</body>
</html>
